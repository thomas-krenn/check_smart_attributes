#!/usr/bin/perl -w

use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case);
use Config::JSON;

our $VERSION = "1.0";
our $VERBOSITY = 0;

use constant {
	STATE_OK => 0,
	STATE_WARNING => 1,
	STATE_CRITICAL => 2,
	STATE_UNKNOWN => 3,
};

our @hdrmap_a = ('ID#','ATTRIBUTE_NAME','FLAG','VALUE','WORST','THRESH',
	'TYPE','UPDATED','WHEN_FAILED','RAW_VALUE');

sub getVersionString{
	return "check_smart_values version $VERSION 20130809
Copyright (C) 2013 Thomas-Krenn.AG (written by Georg Sch√∂nberger)
Current updates available via git repository git.thomas-krenn.com.\n";
}

sub getUsageString{
	return "Usage:
sudo check_smart_values -dbj <smartdb json file> -ucfgj <user config json file>
-p <path to smartctl> [-v|-vv|-vvv] [-h] [-V]\n";
}

sub getHelpString{
	return "
  [-p|--path <path to smartctl]
        Specify the path at which the smartctl binary can be found. Per
        default /usr/sbin/smartctl is taken.
  [-d|--device <path to devices being checked>]
        Specify the devices being monitored. If multiple devices should be
        checked provice the '-d' multiple times. E.g. '-d /dev/sda -d /dev/sdb'
  [-dbj|--dbjson <path to smartdb JSON file>]
        Specify the path at which the JSON smart db can be found. The JSON file
        defines which parameter (VALUE or RAW_VALUE) must be taken for a
        sensor. In order to interpret a sensor it is necessary to know which
        value to take. As this mapping is different for device models a
        database is needed for a device.
  [-ucfgj|--ucfgjson <path to user config JSON file>]
        Specify the path at which the JSON user config file can be found.
        The user config can be used to override threshold and performance base
        config. This can be useful if the thresholds for a specific device must
        be changed (e.g. showing up a non-critical error).
        Note that only sensors whose thresholds are defined are being checked.
        Please ensure to include all smart sensor IDs with their thresholds in
        the user config that should be checked - copying the base config is a
        good starting point.
  [-v <Verbose Level>]
       be verbose
         (no -v) .. single line output
         -v ..... single line output with additional details for warnings
         -vv ..... multi line output, also with additional details for warnings
         -vvv ..... normal output, then debugging output
  [-h|--help]
       show this help
  [-V|--version]
       show version information\n";
}

sub readUCfgJSON{
	my $uCfgJSON = shift;
	return(Config::JSON->new($uCfgJSON));
}

sub readDbJSON{
	my $dbJSON = shift;
	return(Config::JSON->new($dbJSON));
}

sub getSmartctl{
	my $smartctl = shift;
	my @devicesToCheck_a = @{(shift)};
	#a hash of all devices with their corresponding output
	my %output_h;

	foreach my $device (@devicesToCheck_a){
		my @output = `$smartctl -a $device`;
		if(($? >> 8) & 2){
			print "Error: smartctl returned \"No such device\" for device $device.\n";
			exit(STATE_UNKNOWN);
		}
		$output_h{$device} = \@output;
	}
	return \%output_h;
}

sub checkWhichDevice{
	my $dbConfig = shift;
	my $uCfgJSON = shift;
	my %smartctlOut_h = %{(shift)};;
	# Array of found device hashes
	my @devices_a;

	# Fetch the device JSON hash
	my $devices_h = $dbConfig->get("Devices");

	# If given, fetch the user config for the devices
	my $uCfgDevices_h;
	if(defined($uCfgJSON)){
		$uCfgDevices_h = $uCfgJSON->get("Devices");
	}

	# Check all models in the db
	foreach my $key (keys %$devices_h){
		# Check each device whose smartvalues are present
		foreach my $device (keys %smartctlOut_h){
			my @smartctlOut = @{$smartctlOut_h{$device}};
			my @device = grep { /Model Family/i || /Device Model/i } @smartctlOut;
			foreach(@device){
				# If the model matches we have found the correct db entry
				if(($_ =~ $devices_h->{$key}->{'Device'}->[0]) ||
				($_ =~ $devices_h->{$key}->{'Device'}->[1])){
					my %foundDevice_h;
					$foundDevice_h{'Path'} = $device;
					$foundDevice_h{'Device'} = $devices_h->{$key}->{'Device'};
					$foundDevice_h{'ID#'} = $devices_h->{$key}->{'ID#'};
					$foundDevice_h{'Threshs'} = $devices_h->{$key}->{'Threshs'};
					$foundDevice_h{'Perfs'} = $devices_h->{$key}->{'Perfs'};
					# Tresholds and perf variables are defined in the user cfg
					if(defined($uCfgDevices_h->{$device})){
						$foundDevice_h{'Threshs'} = $uCfgDevices_h->{$device}->{'Threshs'};
						$foundDevice_h{'Perfs'} = $uCfgDevices_h->{$device}->{'Perfs'};
					}
					push @devices_a, \%foundDevice_h;
					last;
				}
			}
		}
	}
	return \@devices_a;
}

sub parseSmartctlOut{
	my %smartctlOut_h = %{(shift)};
	# A hash with the parsed smart values for all devices
	my %smartValues_h;

	foreach my $device (keys %smartctlOut_h){
		my @smartctlOut = @{$smartctlOut_h{$device}};
		# Check for smart value lines
		my @smartValues;
		my @splittedLine;
		foreach my $line (@smartctlOut) {
			if($line =~ /\d+\s+\w+\s+0[xX][0-9a-fA-F]+\s+\d+\s+\d+\s+\d+\s+\w+/){
				$line =~ s/^\s+|\s+$//g;
				# Split the found line, and map its elements
				# The header map defines the keys for the hash
				@splittedLine = map { s/^\s*//; s/\s*$//; $_; } split(/\s+/,$line);
				my %lineValues_h;
				for(my $i = 0; $i < @hdrmap_a; $i++){
					# Prepend the attribute name with the device name
					if($hdrmap_a[$i] eq 'ATTRIBUTE_NAME'){
						$device =~ /^\/dev\/(\w+)$/;
						$lineValues_h{$hdrmap_a[$i]} = $1.'_'.$splittedLine[$i];
					}
					else{
						$lineValues_h{$hdrmap_a[$i]} = $splittedLine[$i];
					}
				}
				push @smartValues, \%lineValues_h;
			}
			if($line =~ /(ATA Error Count)\:\s+(\d+)/){
				my %lineValues_h;
				$lineValues_h{'ATTRIBUTE_NAME'} = $1;
				$lineValues_h{'VALUE'} = $2;
				# Modify attribute name
				$device =~ /^\/dev\/(\w+)$/;
				$lineValues_h{'ATTRIBUTE_NAME'} =$1.'_'.$lineValues_h{'ATTRIBUTE_NAME'};
				$lineValues_h{'ATTRIBUTE_NAME'} =~ s/ /_/g;
				$lineValues_h{'ID#'} = 1024;
				push @smartValues, \%lineValues_h;
			}
		}
		$smartValues_h{$device} = \@smartValues;
	}
	return \%smartValues_h;
}

sub checkThreshs{
	my $value = shift;
	my $pattern = shift;

	if($pattern =~ /(^[0-9]*$)/){
		if($value < 0 || $value > $1){
			return 0;
		}
	}
	if($pattern =~ /(^[0-9]*)\:$/){
		if($value < $1){
			return 0;
		}
	}
	if($pattern =~ /^\~\:([0-9]*)$/){
		if($value > $1){
			return 0;
		}
	}
	return 1;
}

sub checkSmartctl{
	my %smartValues_h = %{(shift)};
	my @devices_a = @{(shift)};
	# Resulting status level variables
	my @warnings_a;
	my @criticals_a;
	my @statusLevel_a = ("OK");

	foreach my $device (@devices_a){
		# Fetch the configured variables for a device
		my %IDs_h = %{$device->{'ID#'}};
		my %threshs_h = %{$device->{'Threshs'}};
		my @smartValues_a = @{$smartValues_h{$device->{'Path'}}};
		# Check the corresponding smart values
		foreach my $row (@smartValues_a){
			my $ID = $row->{'ID#'};
			if(exists $IDs_h{$ID} && exists $threshs_h{$ID}){
				if(!(checkThreshs($row->{$IDs_h{$ID}},$threshs_h{$ID}->[0]))){
					# Don't loose the critical state
					$statusLevel_a[0] = 'Warning' unless $statusLevel_a[0] eq 'Critical';
					push @warnings_a, $row->{'ATTRIBUTE_NAME'};
				}
				if(!(checkThreshs($row->{$IDs_h{$ID}},$threshs_h{$ID}->[1]))){
					$statusLevel_a[0] = 'Critical';
					pop @warnings_a;
					push @criticals_a, $row->{'ATTRIBUTE_NAME'};
				}
			}
		}
	}

	push @statusLevel_a, \@warnings_a;
	push @statusLevel_a, \@criticals_a;
	return \@statusLevel_a;
}

sub checkMissingDevicesDB{
	my @devicesToCheck_a = @{(shift)};
	my @devices_a = @{(shift)};
	my $missingDevs_str;
	my $found;
	foreach my $deviceToCheck (@devicesToCheck_a){
		$found = 0;
		foreach my $device (@devices_a){
			if($deviceToCheck eq $device->{'Path'}){
				$found = 1;
				last;
			}
		}
		if($found == 0){
			$missingDevs_str .= ', ' if defined($missingDevs_str);
			$missingDevs_str .= $deviceToCheck
		}
	}
	return $missingDevs_str;
}


sub getStatusString{
	my $level = shift;
	my @statusLevel_a = @{(shift)};
	my %smartValues_h = %{(shift)};
	my @devices_a = @{(shift)};
	# Sensors to check, warn or crit
	my @sensors_a;
	my $status_str = "";

	if($level eq "Warning"){
		@sensors_a = @{$statusLevel_a[1]};
	}
	if($level eq "Critical"){
		@sensors_a = @{$statusLevel_a[2]};
	}

	if($level eq "Warning" || $level eq "Critical"){
		if(@sensors_a){
			# Print which sensors are Warn or Crit
			foreach my $sensor (@sensors_a){
				$status_str .= "[".$sensor." = ".$level;
				if($VERBOSITY){
					$sensor =~ /^([a-zA-Z]+)/;
					my $devicePath = '/dev/'.$1;
					my %IDs_h;
					my @smartValues_a;
					foreach my $device (@devices_a){
						# Search for the device the sensor belongs to
						if($devicePath eq $device->{'Path'}){
							%IDs_h = %{$device->{'ID#'}};
							@smartValues_a = @{$smartValues_h{$device->{'Path'}}};
						}
					}
					# Append the value for the given sensor
					foreach my $row (@smartValues_a){
						if($row->{'ATTRIBUTE_NAME'} eq $sensor){
							my $ID = $row->{'ID#'};
							if(exists $IDs_h{$ID}){
								$status_str .= " (".$row->{$IDs_h{$ID}}.")";
							}
						}
					}
				}
				$status_str .= "]";
			}
		}
	}
	return $status_str;
}
sub getPerfString{
	my %smartValues_h = %{(shift)};
	my @devices_a = @{(shift)};
	my $perf_str;

	foreach my $device (@devices_a){
		# Fetch the configured variables for a device
		my %IDs_h = %{$device->{'ID#'}};
		my %threshs_h = %{$device->{'Threshs'}};
		my @perfmap_a = @{$device->{'Perfs'}};
		my @smartValues_a = @{$smartValues_h{$device->{'Path'}}};

		foreach my $perf (@perfmap_a){
			# Search for the sensor and print its value
			foreach my $row (@smartValues_a){
				if($perf eq $row->{'ID#'}){
					my $ID = $row->{'ID#'};
					my $attr_str;
					if(exists $IDs_h{$ID}){
						$attr_str = $row->{'ATTRIBUTE_NAME'}."=".$row->{$IDs_h{$ID}};
						if($perf_str){
							$attr_str = " ".$attr_str;
						}
					}
					$perf_str .= $attr_str;
					# If available also print its thresholds
					if(exists $IDs_h{$ID} && exists $threshs_h{$ID}){
						$threshs_h{$ID}->[0] =~ /(\d+)/;
						$perf_str .= ';'.$1.';';
						$threshs_h{$ID}->[1] =~ /(\d+)/;
						$perf_str .= $1;
					}
				}
			}
		}
	}
	return $perf_str;
}

sub getVerboseString{
	my %smartValues_h = %{(shift)};
	my @devices_a = @{(shift)};
	my %smartctlOut_h = %{(shift)};
	my $verb_str;

	foreach my $device (@devices_a){
		# Fetch the configured variables for a device
		my %IDs_h = %{$device->{'ID#'}};
		my %threshs_h = %{$device->{'Threshs'}};
		my @perfmap_a = @{$device->{'Perfs'}};
		my @smartValues_a = @{$smartValues_h{$device->{'Path'}}};

		foreach my $row (@smartValues_a){
			my $ID = $row->{'ID#'};
			if(exists $IDs_h{$ID}){
				$verb_str .= "\n".$row->{'ATTRIBUTE_NAME'}." = ".$row->{$IDs_h{$ID}};
				$verb_str .= " (".$IDs_h{$ID}.")";
			}
		}
		if($VERBOSITY == 3){
			my @smartctlOut = @{$smartctlOut_h{$device->{'Path'}}};
			$verb_str .= "\n======================================== \n";
			$verb_str .= "Device: ".$device->{'Path'}."\n";
			$verb_str .= "\n================= \n";
			$verb_str .= "Thresholds:\n";
			foreach my $ID (keys %threshs_h){
				$verb_str .= $ID.": [".$threshs_h{$ID}->[0].",".$threshs_h{$ID}->[1]."]\n";
			}
			$verb_str .= "================= \n";
			$verb_str .= "Performance Value IDs:\n";
			$verb_str .= "[@perfmap_a]\n";
			$verb_str .= "================= \n";
			$verb_str .= "Begin of smartctl output:\n";
			foreach my $line (@smartctlOut){
				$verb_str .= $line;
			}
			$verb_str .= "\nEnd of verbose output for device: ".$device->{'Path'}."\n";
			$verb_str .= "======================================== \n";
		}
	}

	return $verb_str;
}

MAIN: {
	my ($smartctl, $dbJSON, $uCfgJSON, $exitCode, $noSudo);
	my @devicesToCheck_a;
	if ( !(GetOptions(
		'v|verbose' => sub { $VERBOSITY = 1 },
		'vv' => sub { $VERBOSITY = 2 },
		'vvv' => sub { $VERBOSITY = 3 },
		'h|help' => sub {
			print getVersionString();
			print getUsageString();
			print getHelpString();
			exit(STATE_OK);
		;},
		'p|path=s' => \$smartctl,
		'dbj|dbjson=s' => \$dbJSON,
		'd|device=s' => \@devicesToCheck_a,
		'ucfgj|ucfgjson=s' => \$uCfgJSON,
		'nosudo' => \$noSudo,
		'V|version' => sub{
			print getVersionString()."\n";
			exit(STATE_OK);
		},
	)))	{
		print getUsageString();
		exit(STATE_UNKNOWN);
	}
	# Check smartclt tool
	if(!defined($smartctl)){
		$smartctl = "/usr/sbin/smartctl";
	}
	if(! -x $smartctl){
		print "Error: cannot find smartctl executable.\n";
		exit(STATE_UNKNOWN);
	}
	# Check for sudo unless disabled
	if(!defined($noSudo)){
		my $sudo;
		chomp($sudo = `which sudo`);
		if(! -x $sudo){
			print "Error: cannot find sudo executable.\n";
			exit(STATE_UNKNOWN);
		}
		$smartctl = $sudo.' '.$smartctl;
	}
	# The smartdb must be present
	if(!defined($dbJSON)){
		print "Error: smartctl requires a valid smartdb JSON file.\n";
		print getUsageString();
		exit(STATE_UNKNOWN);
	}
	# Devices to check are required
	if(!(@devicesToCheck_a)){
		print "Error: check_smart_values requires a device to check.\n";
		print getUsageString();
		exit(STATE_UNKNOWN);
	}
	# Check if a user config is given
	my $uCfg;
	if(defined($uCfgJSON)){
		$uCfg = readUCfgJSON($uCfgJSON);
	}
	my $output_h = getSmartctl($smartctl,\@devicesToCheck_a);
	my $dbConfig = readDbJSON($dbJSON);
	my $devices_a = checkWhichDevice($dbConfig,$uCfg,$output_h);
	if(!(@$devices_a)){
		print "Error: device was not found in smartdb JSON file.\n";
		exit(STATE_UNKNOWN);
	}
	# Not all devices were found in the smartdb JSON
	if(@$devices_a != @devicesToCheck_a){
		print "Error: the following device(s) where not found in the smartdb JSON file: ";
		print checkMissingDevicesDB(\@devicesToCheck_a,$devices_a);
		exit(STATE_UNKNOWN);
	}
	my $smartValues_h = parseSmartctlOut($output_h);
	my $statusLevel_a = checkSmartctl($smartValues_h,$devices_a);

	$exitCode = STATE_OK;
	if($statusLevel_a->[0] eq "Critical"){
		$exitCode = STATE_CRITICAL;
	}
	if($statusLevel_a->[0] eq "Warning"){
		$exitCode = STATE_WARNING;
	}

	print $statusLevel_a->[0];
	print' (';
	my $dev_str;
	foreach my $devChecked (@$devices_a){
		$dev_str .= ', ' if defined($dev_str);
		$devChecked->{'Path'} =~ /^\/dev\/(\w+)$/;
		$dev_str .= $1;
	}
	$dev_str .= ') ';
	print $dev_str;
	print getStatusString("Critical",$statusLevel_a,$smartValues_h,$devices_a);
	print getStatusString("Warning",$statusLevel_a,$smartValues_h,$devices_a);
	my $perf_str = getPerfString($smartValues_h,$devices_a);
	if($perf_str){
		print "|".$perf_str;
	}
	if($VERBOSITY == 2 || $VERBOSITY == 3){
		print getVerboseString($smartValues_h,$devices_a,$output_h);
	}
	exit ($exitCode);
}